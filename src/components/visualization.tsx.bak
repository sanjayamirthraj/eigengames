//@ts-nocheck

import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faPlay, faPause, faSync } from '@fortawesome/free-solid-svg-icons';
import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

const EthereumTransactionBatching = () => {
  const batchMountRef = useRef(null);
  const individualMountRef = useRef(null);
  const [isSimulating, setIsSimulating] = useState(false);
  const [step, setStep] = useState(0);
  const [explanation, setExplanation] = useState('Click "Start Comparison" to begin');
  const [isInitialized, setIsInitialized] = useState(false);
  const [comparisonStats, setComparisonStats] = useState(null);
  const [isResetting, setIsResetting] = useState(false);

  // Initialize scene elements for batch processing
  const batchSceneRef = useRef(null);
  const batchRendererRef = useRef(null);
  const batchCameraRef = useRef(null);
  const batchTransactionsRef = useRef([]);
  const batchAnimationFrameRef = useRef(null);
  const batchMempoolRef = useRef(null);
  const batchContainersRef = useRef([]);
  const batchBlockRef = useRef(null);

  // Initialize scene elements for individual processing
  const indivSceneRef = useRef(null);
  const indivRendererRef = useRef(null);
  const indivCameraRef = useRef(null);
  const indivTransactionsRef = useRef([]);
  const indivAnimationFrameRef = useRef(null);
  const indivMempoolRef = useRef(null);
  const indivBlockRef = useRef(null);

  // Add new refs for CSS2D renderers
  const batchLabelRendererRef = useRef(null);
  const indivLabelRendererRef = useRef(null);

  // Initialize both Three.js scenes
  const initThreeJs = () => {
    if (!batchMountRef.current || !individualMountRef.current || isInitialized) return;
    
    // Initialize batch processing scene
    const batchScene = new THREE.Scene();
    batchScene.background = new THREE.Color(0xf8fafc);
    batchSceneRef.current = batchScene;
    
    const batchCamera = new THREE.PerspectiveCamera(
      60,
      batchMountRef.current.clientWidth / batchMountRef.current.clientHeight,
      0.1,
      1000
    );
    // Change camera to top-down view with slight angle
    batchCamera.position.set(0, 40, 10);
    batchCamera.lookAt(0, 0, 0);
    batchCameraRef.current = batchCamera;
    
    const batchRenderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: true
    });
    batchRenderer.setSize(batchMountRef.current.clientWidth, batchMountRef.current.clientHeight);
    batchRenderer.shadowMap.enabled = true;
    batchRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    while (batchMountRef.current.firstChild) {
      batchMountRef.current.removeChild(batchMountRef.current.firstChild);
    }
    batchMountRef.current.appendChild(batchRenderer.domElement);
    batchRendererRef.current = batchRenderer;

    // Initialize individual processing scene
    const indivScene = new THREE.Scene();
    indivScene.background = new THREE.Color(0xf8fafc);
    indivSceneRef.current = indivScene;
    
    const indivCamera = new THREE.PerspectiveCamera(
      60,
      individualMountRef.current.clientWidth / individualMountRef.current.clientHeight,
      0.1,
      1000
    );
    // Change camera to top-down view with slight angle
    indivCamera.position.set(0, 40, 10);
    indivCamera.lookAt(0, 0, 0);
    indivCameraRef.current = indivCamera;
    
    const indivRenderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: true
    });
    indivRenderer.setSize(individualMountRef.current.clientWidth, individualMountRef.current.clientHeight);
    indivRenderer.shadowMap.enabled = true;
    indivRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    while (individualMountRef.current.firstChild) {
      individualMountRef.current.removeChild(individualMountRef.current.firstChild);
    }
    individualMountRef.current.appendChild(indivRenderer.domElement);
    indivRendererRef.current = indivRenderer;
    
    // Add lighting to both scenes
    [batchScene, indivScene].forEach(scene => {
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
      const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
      mainLight.position.set(10, 20, 15);
      mainLight.castShadow = true;
      scene.add(mainLight);
      
      const fillLight = new THREE.DirectionalLight(0xe2e8f0, 0.4);
      fillLight.position.set(-10, 10, -10);
      scene.add(fillLight);
      
      const backLight = new THREE.DirectionalLight(0xf1f5f9, 0.3);
      backLight.position.set(0, -10, -10);
      scene.add(backLight);
    });
    
    // Create visualizations for both scenes
    createBlockchain(batchScene, batchBlockRef);
    createBlockchain(indivScene, indivBlockRef);
    createMempool(batchScene, batchMempoolRef);
    createMempool(indivScene, indivMempoolRef);
    createBatchingArea(batchScene);
    
    // Set up animation loop for both scenes
    const animate = () => {
      batchAnimationFrameRef.current = requestAnimationFrame(animate);
      
      if (batchMempoolRef.current) {
        batchMempoolRef.current.rotation.y += 0.003;
      }
      if (indivMempoolRef.current) {
        indivMempoolRef.current.rotation.y += 0.003;
      }
      
      batchRenderer.render(batchScene, batchCamera);
      indivRenderer.render(indivScene, indivCamera);
    };
    
    animate();
    
    setIsInitialized(true);
  };

  // Animation function for batch scene
  const animateBatchScene = () => {
    if (batchMempoolRef.current) {
      batchMempoolRef.current.rotation.y += 0.003;
    }
  };

  // Animation function for individual scene
  const animateIndivScene = () => {
    if (indivMempoolRef.current) {
      indivMempoolRef.current.rotation.y += 0.003;
    }
  };

  useEffect(() => {
    if (!isInitialized) {
      // Setup batch processing scene
      const batchCleanup = setupScene(
        batchMountRef,
        batchSceneRef,
        batchCameraRef,
        batchRendererRef,
        batchLabelRendererRef,
        animateBatchScene
      );
      
      // Setup individual processing scene
      const indivCleanup = setupScene(
        indivMountRef,
        indivSceneRef,
        indivCameraRef,
        indivRendererRef,
        indivLabelRendererRef,
        animateIndivScene
      );
      
      // Initialize both scenes
      if (batchSceneRef.current) {
        createMempool(batchSceneRef.current, { x: -22, y: 0, z: 0 }, batchMempoolRef);
        createBlockchain(batchSceneRef.current, batchBlockRef);
        createBatchingArea(batchSceneRef.current, batchContainersRef);
      }
      
      if (indivSceneRef.current) {
        createMempool(indivSceneRef.current, { x: -22, y: 0, z: 0 }, indivMempoolRef);
        createBlockchain(indivSceneRef.current, indivBlockRef);
      }
      
      setIsInitialized(true);
      
      // Cleanup function
      return () => {
        batchCleanup && batchCleanup();
        indivCleanup && indivCleanup();
      };
    }
  }, [isInitialized]);
  
  // Create blockchain visualization - adjust positions for better top-down view
  const createBlockchain = (scene, blockRef) => {
    if (!scene) return;
    
    const blockchainGroup = new THREE.Group();
    blockchainGroup.position.set(15, 0, 0); // Moved closer to center
    
    // Create several blocks
    for (let i = 0; i < 5; i++) {
      const blockGeo = new THREE.BoxGeometry(4, 2, 3);
      const blockMat = new THREE.MeshStandardMaterial({
        color: 0xe2e8f0, // Light gray
        metalness: 0.2,
        roughness: 0.3,
        emissive: 0xf1f5f9,
        emissiveIntensity: 0.2
      });
      const block = new THREE.Mesh(blockGeo, blockMat);
      
      // Position blocks in a chain
      block.position.set(i * 5, 0, 0);
      block.castShadow = true;
      block.receiveShadow = true;
      
      // Add hash lines connecting blocks
      if (i > 0) {
        const hashLineGeo = new THREE.CylinderGeometry(0.08, 0.08, 5, 8);
        const hashLineMat = new THREE.MeshBasicMaterial({ 
          color: 0x3b82f6,
          transparent: true,
          opacity: 0.6
        });
        const hashLine = new THREE.Mesh(hashLineGeo, hashLineMat);
        hashLine.rotation.z = Math.PI / 2;
        hashLine.position.set(i * 5 - 2.5, 0, 0);
        blockchainGroup.add(hashLine);
      }
      
      blockchainGroup.add(block);
    }
    
    // Create newer block being processed
    const newBlockGeo = new THREE.BoxGeometry(4, 2, 3);
    const newBlockMat = new THREE.MeshStandardMaterial({
      color: 0x60a5fa, // Light blue
      metalness: 0.3,
      roughness: 0.2,
      transparent: true,
      opacity: 0.9,
      emissive: 0x3b82f6,
      emissiveIntensity: 0.2
    });
    const newBlock = new THREE.Mesh(newBlockGeo, newBlockMat);
    newBlock.position.set(25, 0, 0);
    newBlock.castShadow = true;
    newBlock.receiveShadow = true;
    blockRef.current = newBlock;
    
    const hashLineGeo = new THREE.CylinderGeometry(0.08, 0.08, 5, 8);
    const hashLineMat = new THREE.MeshBasicMaterial({ 
      color: 0x3b82f6,
      transparent: true,
      opacity: 0.6
    });
    const hashLine = new THREE.Mesh(hashLineGeo, hashLineMat);
    hashLine.rotation.z = Math.PI / 2;
    hashLine.position.set(22.5, 0, 0);
    
    blockchainGroup.add(hashLine);
    blockchainGroup.add(newBlock);
    
    scene.add(blockchainGroup);
    
    // Add a label for the blockchain
    createLabel('Blockchain', {
      x: 15, // Match the blockchain x-position
      y: 2, // Slightly above the blockchain
      z: 0
    }, scene);
  };
  
  // Create mempool visualization - adjust positions for better top-down view
  const createMempool = (scene, mempoolRef) => {
    if (!scene) return;
    
    const mempoolGroup = new THREE.Group();
    mempoolGroup.position.set(-22, 0, 0); // Moved further left to avoid overlap
    
    // Create a mempool container with glowing effect
    const geometry = new THREE.CylinderGeometry(7, 7, 1, 32);
    const material = new THREE.MeshStandardMaterial({
      color: 0xf1f5f9, // Very light gray
      transparent: true,
      opacity: 0.8,
      metalness: 0.2,
      roughness: 0.3,
      emissive: 0xe2e8f0,
      emissiveIntensity: 0.2
    });
    const mempool = new THREE.Mesh(geometry, material);
    mempool.castShadow = true;
    mempool.receiveShadow = true;
    mempoolRef.current = mempool;
    mempoolGroup.add(mempool);
    
    // Add glow effect ring
    const glowGeo = new THREE.TorusGeometry(7.2, 0.2, 16, 32);
    const glowMat = new THREE.MeshBasicMaterial({ 
      color: 0x3b82f6,
      transparent: true,
      opacity: 0.4
    });
    const glowRing = new THREE.Mesh(glowGeo, glowMat);
    glowRing.rotation.x = Math.PI / 2;
    mempoolGroup.add(glowRing);
    
    scene.add(mempoolGroup);
    
    // Add label above the mempool
    createLabel('Mempool', {
      x: -22, 
      y: 1, 
      z: 0
    }, scene);
  };
  
  // Create batching area
  const createBatchingArea = (scene) => {
    if (!scene) return;
    
    const batchingGroup = new THREE.Group();
    batchingGroup.position.set(5, 0, 0); // Moved right to avoid overlap with mempool
    
    // Create batching area platform with glowing edges
    const geometry = new THREE.BoxGeometry(20, 0.5, 10);
    const material = new THREE.MeshStandardMaterial({
      color: 0xf8fafc, // Lightest gray
      transparent: true,
      opacity: 0.9,
      metalness: 0.2,
      roughness: 0.3,
      emissive: 0xf1f5f9,
      emissiveIntensity: 0.2
    });
    const platform = new THREE.Mesh(geometry, material);
    platform.position.y = 0;
    platform.receiveShadow = true;
    batchingGroup.add(platform);
    
    // Add platform glow edges
    const edgeGeo = new THREE.BoxGeometry(20.2, 0.1, 10.2);
    const edgeMat = new THREE.MeshBasicMaterial({
      color: 0x3b82f6,
      transparent: true,
      opacity: 0.4
    });
    const edges = new THREE.Mesh(edgeGeo, edgeMat);
    edges.position.y = 0.2;
    batchingGroup.add(edges);
    
    // Create batch containers
    const batchPositions = [
      { x: -7.5, z: 0 },
      { x: -2.5, z: 0 },
      { x: 2.5, z: 0 },
      { x: 7.5, z: 0 }
    ];
    
    const batches = [];
    
    batchPositions.forEach((pos) => {
      const batchGeo = new THREE.BoxGeometry(4, 0.5, 6);
      const batchMat = new THREE.MeshStandardMaterial({
        color: 0xe2e8f0,
        transparent: true,
        opacity: 0.9,
        metalness: 0.2,
        roughness: 0.3,
        emissive: 0xf1f5f9,
        emissiveIntensity: 0.2
      });
      const batch = new THREE.Mesh(batchGeo, batchMat);
      batch.position.set(pos.x, 0.5, pos.z);
      batch.castShadow = true;
      batch.receiveShadow = true;
      batchingGroup.add(batch);
      batches.push(batch);
      
      // Add glow effect to batch containers
      const batchGlow = new THREE.Mesh(
        new THREE.BoxGeometry(4.2, 0.1, 6.2),
        new THREE.MeshBasicMaterial({
          color: 0x3b82f6,
          transparent: true,
          opacity: 0.3
        })
      );
      batchGlow.position.set(pos.x, 0.8, pos.z);
      batchingGroup.add(batchGlow);
    });
    
    batchContainersRef.current = batches;
    scene.add(batchingGroup);
    
    // Add a label for the batching area
    createLabel('Batching Area', {
      x: 5, // Match the batching area x-position
      y: 2, // Slightly above the batching area
      z: 0
    }, scene);
  };
  
  // Create transaction object with enhanced visuals
  const createTransaction = (id, state) => {
    const geometry = new THREE.BoxGeometry(0.8, 0.3, 0.8);
    
    let color, emissiveColor, emissiveIntensity;
    switch (state) {
      case 0: 
        color = 0x22c55e; // Bright green
        emissiveColor = 0x15803d;
        emissiveIntensity = 0.2;
        break;
      case 1: 
        color = 0x3b82f6; // Bright blue
        emissiveColor = 0x1d4ed8;
        emissiveIntensity = 0.2;
        break;
      case 2: 
        color = 0xfacc15; // Bright yellow
        emissiveColor = 0xca8a04;
        emissiveIntensity = 0.2;
        break;
      case 3: 
        color = 0xef4444; // Bright red
        emissiveColor = 0xb91c1c;
        emissiveIntensity = 0.2;
        break;
      case 4: 
        color = 0xa855f7; // Bright purple
        emissiveColor = 0x7e22ce;
        emissiveIntensity = 0.2;
        break;
      default: 
        color = 0x94a3b8;
        emissiveColor = 0x64748b;
        emissiveIntensity = 0.1;
    }
    
    const material = new THREE.MeshStandardMaterial({
      color: color,
      metalness: 0.3,
      roughness: 0.2,
      emissive: emissiveColor,
      emissiveIntensity: emissiveIntensity
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    
    // Store transaction data
    mesh.userData = {
      id: id,
      state: state,
      batch: null,
      fee: Math.random() * 0.5 + 0.1 // Random fee between 0.1 and 0.6 ETH
    };
    
    return mesh;
  };
  
  // Generate transactions
  const generateTransactions = (scene, mempoolRef, transactionsRef) => {
    if (!scene || !mempoolRef.current) return [];
    
    const transactions = [];
    
    // Clear any existing transactions
    transactionsRef.current.forEach(tx => {
      if (scene) scene.remove(tx);
    });
    
    transactionsRef.current = [];
    
    // Get mempool position
    const mempoolPosition = new THREE.Vector3(-22, 0, 0); // Updated to match new mempool position
    
    // Create new transactions
    for (let i = 0; i < 20; i++) {
      const state = Math.floor(Math.random() * 5);
      const tx = createTransaction(`tx-${i}`, state);
      
      if (tx) {
        // Random position within mempool cylinder
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 5; // Slightly smaller than mempool radius
        tx.position.set(
          mempoolPosition.x + Math.cos(angle) * radius,
          mempoolPosition.y + Math.random() * 0.5 + 0.5, // Slightly raised for visibility
          mempoolPosition.z + Math.sin(angle) * radius
        );
        
        scene.add(tx);
        transactions.push(tx);
        transactionsRef.current.push(tx);
      }
    }
    
    return transactions;
  };
  
  // Batch transactions by state
  const batchTransactions = (transactions) => {
    const batches = [[], [], [], []];
    const statesInBatch = [{}, {}, {}, {}];
    
    // Make a copy to avoid modifying original
    const pendingTxs = [...transactions];
    
    while (pendingTxs.length > 0) {
      const tx = pendingTxs.shift();
      if (!tx) continue;
      
      let assigned = false;
      const txState = tx.userData.state;
      
      // Try to assign to a batch
      for (let i = 0; i < batches.length; i++) {
        // Check if batch is full (max 6 txs per batch)
        if (batches[i].length >= 6) continue;
        
        // Check if state already in batch
        if (statesInBatch[i][txState]) continue;
        
        // Add to batch
        batches[i].push(tx);
        tx.userData.batch = i;
        statesInBatch[i][txState] = true;
        assigned = true;
        break;
      }
      
      // If couldn't assign to any batch, add to least full batch
      if (!assigned) {
        let minBatchSize = Infinity;
        let minBatchIndex = 0;
        
        for (let i = 0; i < batches.length; i++) {
          if (batches[i].length < minBatchSize) {
            minBatchSize = batches[i].length;
            minBatchIndex = i;
          }
        }
        
        batches[minBatchIndex].push(tx);
        tx.userData.batch = minBatchIndex;
      }
    }
    
    return batches;
  };
  
  // Helper for animation
  const animatePosition = (object, targetPosition, duration) => {
    return new Promise(resolve => {
      const startPosition = { 
        x: object.position.x,
        y: object.position.y, 
        z: object.position.z 
      };
      const startTime = Date.now();
      
      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        object.position.x = startPosition.x + (targetPosition.x - startPosition.x) * progress;
        object.position.y = startPosition.y + (targetPosition.y - startPosition.y) * progress;
        object.position.z = startPosition.z + (targetPosition.z - startPosition.z) * progress;
        
        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          resolve();
        }
      }
      
      update();
    });
  };
  
  // Helper for camera animation
  const animateCamera = (camera, targetPosition, targetLookAt, duration) => {
    return new Promise(resolve => {
      const startPosition = { 
        x: camera.position.x,
        y: camera.position.y, 
        z: camera.position.z 
      };
      
      // Get current lookAt by creating a vector from camera position to current target
      const startLookAt = new THREE.Vector3(0, 0, 0);
      camera.getWorldDirection(startLookAt);
      startLookAt.multiplyScalar(100).add(camera.position); // Extend the direction vector and add camera position
      
      const startTime = Date.now();
      
      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        // Ease in/out curve for smoother motion
        const easedProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
        
        // Update camera position
        camera.position.x = startPosition.x + (targetPosition.x - startPosition.x) * easedProgress;
        camera.position.y = startPosition.y + (targetPosition.y - startPosition.y) * easedProgress;
        camera.position.z = startPosition.z + (targetPosition.z - startPosition.z) * easedProgress;
        
        // Update lookAt
        const lookAtX = startLookAt.x + (targetLookAt.x - startLookAt.x) * easedProgress;
        const lookAtY = startLookAt.y + (targetLookAt.y - startLookAt.y) * easedProgress;
        const lookAtZ = startLookAt.z + (targetLookAt.z - startLookAt.z) * easedProgress;
        
        camera.lookAt(lookAtX, lookAtY, lookAtZ);
        
        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          camera.lookAt(targetLookAt.x, targetLookAt.y, targetLookAt.z);
          resolve();
        }
      }
      
      update();
    });
  };
  
  // Get position along a path
  const getPathPosition = (path, progress) => {
    // Sample the path at the given progress (0-1)
    const point = path.getPointAt(progress);
    
    return {
      x: point.x,
      y: point.y,
      z: point.z
    };
  };

  // Animate along a path with camera following
  const animateAlongPath = (object, path, duration, camera, finalPosition = null) => {
    return new Promise(resolve => {
      const startTime = Date.now();
      
      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Follow path for first 80% of animation
        if (progress < 0.8 || !finalPosition) {
          const pathProgress = finalPosition ? progress / 0.8 : progress;
          const pathPos = getPathPosition(path, pathProgress);
          
          // Update object position
          object.position.set(pathPos.x, pathPos.y, pathPos.z);
          
          // Update camera to follow if provided
          if (camera) {
            // Calculate camera position to follow the object
            const cameraOffset = { x: 3, y: 5, z: 3 };
            camera.position.set(
              pathPos.x + cameraOffset.x,
              pathPos.y + cameraOffset.y,
              pathPos.z + cameraOffset.z
            );
            camera.lookAt(pathPos.x, pathPos.y, pathPos.z);
          }
        } else if (finalPosition) {
          // Last 20% moves to final position
          const finalProgress = (progress - 0.8) / 0.2;
          const pathPos = getPathPosition(path, 1);
          
          object.position.x = pathPos.x + (finalPosition.x - pathPos.x) * finalProgress;
          object.position.y = pathPos.y + (finalPosition.y - pathPos.y) * finalProgress;
          object.position.z = pathPos.z + (finalPosition.z - pathPos.z) * finalProgress;
          
          // Update camera to follow
          if (camera) {
            const cameraOffset = { x: 3, y: 5, z: 3 };
            camera.position.set(
              object.position.x + cameraOffset.x,
              object.position.y + cameraOffset.y,
              object.position.z + cameraOffset.z
            );
            camera.lookAt(object.position.x, object.position.y, object.position.z);
          }
        }
        
        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          resolve();
        }
      }
      
      update();
    });
  };

  // Run the individual transaction simulation
  const runIndividualSimulation = async () => {
    if (!indivSceneRef.current || !indivCameraRef.current) return;
    
    const startTime = performance.now();
    let transactionsProcessed = 0;
    
    try {
      // Reset camera to overview position
      const camera = indivCameraRef.current;
      await animateCamera(
        camera,
        { x: 0, y: 40, z: 10 },
        { x: 0, y: 0, z: 0 },
        1000
      );
      
      // Step 1: Generate transactions in mempool
      setStep(1);
      setExplanation('Step 1: Transactions enter the mempool (Individual Processing)');
      
      // Move camera to focus on mempool
      await animateCamera(
        camera,
        { x: -22, y: 15, z: 15 }, // Updated for new mempool position
        { x: -22, y: 0, z: 0 },
        1500
      );
      
      const transactions = generateTransactions(indivSceneRef.current, indivMempoolRef, indivTransactionsRef);
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Step 2: Sort transactions by fee
      setStep(2);
      setExplanation('Step 2: Transactions are sorted by fee for individual processing');
      
      // Highlight each transaction briefly to simulate sorting
      for (const tx of transactions) {
        const originalColor = tx.material.color.clone();
        tx.material.color.set(0xffffff);
        await new Promise(resolve => setTimeout(resolve, 30)); // faster highlighting
        tx.material.color.copy(originalColor);
      }
      
      // Sort transactions by fee (color)
      transactions.sort((a, b) => {
        const colorA = new THREE.Color(a.material.color.getHex());
        const colorB = new THREE.Color(b.material.color.getHex());
        
        // Use hue as a proxy for fee amount
        const hueA = new THREE.Color(colorA).getHSL({}).h;
        const hueB = new THREE.Color(colorB).getHSL({}).h;
        
        // Higher fee (more red/orange) gets priority
        return hueB - hueA;
      });
      
      // Briefly pause after sorting
      await new Promise(resolve => setTimeout(resolve, 800));
      
      // Step 3: Process transactions individually
      setStep(3);
      setExplanation('Step 3: Transactions are processed sequentially into blocks');
      
      // Move camera to see both mempool and blockchain
      await animateCamera(
        camera,
        { x: -5, y: 20, z: 20 }, // Position to see both mempool and blockchain
        { x: 0, y: 0, z: 0 },
        1500
      );
      
      // Create two blocks to fill
      const blockGeo = new THREE.BoxGeometry(4, 1.5, 4);
      const blockMat = new THREE.MeshPhongMaterial({
        color: 0xf8fafc,
        transparent: true,
        opacity: 0.9,
        emissive: 0xf1f5f9,
        emissiveIntensity: 0.2,
      });
      
      // Create two empty blocks in the blockchain
      const block1 = new THREE.Mesh(blockGeo, blockMat.clone());
      block1.position.set(15, 0, -3);
      indivSceneRef.current.add(block1);
      
      const block2 = new THREE.Mesh(blockGeo, blockMat.clone());
      block2.position.set(15, 0, 3);
      indivSceneRef.current.add(block2);
      
      // Process transactions one by one, filling blocks sequentially
      let block1Count = 0;
      let block2Count = 0;
      
      for (let i = 0; i < transactions.length; i++) {
        const tx = transactions[i];
        
        // Determine which block to place this transaction in (alternate)
        const targetBlock = i % 2 === 0 ? block1 : block2;
        const count = i % 2 === 0 ? block1Count++ : block2Count++;
        
        // Calculate position within block
        const rowCol = count < 3 ? 
          { row: 0, col: count } : 
          { row: 1, col: count - 3 };
        
        // Calculate final position inside the block
        const finalPosition = {
          x: targetBlock.position.x - 1 + rowCol.col * 0.8,
          y: targetBlock.position.y + 0.5 + rowCol.row * 0.4, // Flatter for top-down visibility
          z: targetBlock.position.z - 0.5 + rowCol.row * 0.5
        };
        
        // Highlight transaction being processed
        const originalColor = tx.material.color.clone();
        const originalEmissive = tx.material.emissive.clone();
        const originalEmissiveIntensity = tx.material.emissiveIntensity;
        
        tx.material.color.set(0x22c55e);
        tx.material.emissive.set(0x15803d);
        tx.material.emissiveIntensity = 0.5;
        
        // Short pause before processing this transaction
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Focus camera on current transaction
        await animateCamera(
          camera,
          { x: tx.position.x, y: 10, z: tx.position.z + 5 },
          { x: tx.position.x, y: tx.position.y, z: tx.position.z },
          600
        );
        
        // Scale down transaction for block
        tx.scale.set(0.5, 0.5, 0.5);
        
        // Create path to block
        const pathCurve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(tx.position.x, tx.position.y, tx.position.z),
          new THREE.Vector3((tx.position.x + finalPosition.x) * 0.5, 
                           Math.max(tx.position.y, finalPosition.y) + 3, // Arc height
                           (tx.position.z + finalPosition.z) * 0.5),
          new THREE.Vector3(finalPosition.x, finalPosition.y, finalPosition.z)
        ]);
        
        // Create visual path
        const pathGeo = new THREE.TubeGeometry(
          pathCurve,
          64, // path segments
          0.05, // tube radius
          8, // tubular segments
          false // closed
        );
        
        const pathMat = new THREE.MeshBasicMaterial({
          color: 0x22c55e,
          transparent: true,
          opacity: 0.4,
        });
        
        const path = new THREE.Mesh(pathGeo, pathMat);
        indivSceneRef.current.add(path);
        
        // Follow transaction with camera
        await animateAlongPath(
          tx,
          pathCurve,
          1000, // Slower animation for individual processing
          camera,
          finalPosition
        );
        
        // Remove path
        indivSceneRef.current.remove(path);
        
        // Reset transaction material
        tx.material.color.copy(originalColor);
        tx.material.emissive.copy(originalEmissive);
        tx.material.emissiveIntensity = originalEmissiveIntensity;
        
        // Update transactions processed count
        transactionsProcessed++;
        
        // Add visual indicator for processed transaction
        const indicatorGeo = new THREE.RingGeometry(0.3, 0.4, 16);
        const indicatorMat = new THREE.MeshBasicMaterial({
          color: 0x22c55e,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
        
        const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
        indicator.position.set(finalPosition.x, finalPosition.y + 0.5, finalPosition.z);
        indicator.rotation.x = Math.PI / 2;
        indivSceneRef.current.add(indicator);
        
        // Fade out indicator
        const fadeOutIndicator = () => {
          return new Promise(resolve => {
            let opacity = 0.7;
            const fadeInterval = setInterval(() => {
              opacity -= 0.05;
              indicatorMat.opacity = opacity;
              
              if (opacity <= 0) {
                clearInterval(fadeInterval);
                indivSceneRef.current.remove(indicator);
                resolve();
              }
            }, 50);
          });
        };
        
        // Let indicator fade out while continuing to next transaction
        fadeOutIndicator();
      }
      
      // Show block is mined - focus on the blockchain
      if (indivBlockRef.current) {
        await animateCamera(
          camera,
          { x: 15, y: 10, z: 10 },
          { x: 15, y: 0, z: 0 },
          1000
        );
        
        indivBlockRef.current.material.color.set(0x10b981);
      }
      
      // Zoom out to show the full scene after completion
      await animateCamera(
        camera,
        { x: 0, y: 30, z: 20 },
        { x: 0, y: 0, z: 0 },
        1500
      );
      
      // Wait for a moment to show the completed state
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Calculate final statistics
      const endTime = performance.now();
      const totalTimeIndividual = ((endTime - startTime) / 1000).toFixed(1);
      
      // Final overview and summary
      await animateCamera(
        camera,
        { x: 0, y: 30, z: 20 },
        { x: 0, y: 0, z: 0 },
        1000
      );
      
      // Show final message
      setExplanation(`Individual Processing: ${transactionsProcessed} transactions processed in ${totalTimeIndividual}s`);
      
      return { transactionsProcessed, time: parseFloat(totalTimeIndividual) };
    } catch (error) {
      console.error('Error in individual simulation:', error);
      return { transactionsProcessed: 0, time: 0 };
    }
  };
  
  // Run batch simulation (optimized method)
  const runBatchSimulation = async () => {
    if (!batchSceneRef.current || !batchCameraRef.current) return;
    
    const startTime = performance.now();
    let transactionsProcessed = 0;
    
    try {
      // Reset camera to overview position
      const camera = batchCameraRef.current;
      await animateCamera(
        camera,
        { x: 0, y: 40, z: 10 },
        { x: 0, y: 0, z: 0 },
        1000
      );
      
      // Step 1: Generate transactions in mempool
      setStep(1);
      setExplanation('Step 1: Transactions enter the mempool (Batch Processing)');
      
      // Move camera to focus on mempool
      await animateCamera(
        camera,
        { x: -22, y: 15, z: 15 }, // Updated camera position to match new mempool position
        { x: -22, y: 0, z: 0 },
        1500
      );
      
      const transactions = generateTransactions(batchSceneRef.current, batchMempoolRef, batchTransactionsRef);
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Step 2: Analyze transactions
      setStep(2);
      setExplanation('Step 2: Transactions are analyzed for state conflicts');
      
      // Highlight each transaction briefly to simulate analysis
      for (const tx of transactions) {
        const originalColor = tx.material.color.clone();
        tx.material.color.set(0xffffff);
        await new Promise(resolve => setTimeout(resolve, 30)); // Faster analysis
        tx.material.color.copy(originalColor);
      }
      
      await new Promise(resolve => setTimeout(resolve, 800));
      
      // Step 3: Batch transactions
      setStep(3);
      setExplanation('Step 3: Transactions are batched based on compatibility');
      
      // Move camera to focus on batching area
      await animateCamera(
        camera,
        { x: 5, y: 15, z: 15 }, // Updated to match new batching area position
        { x: 5, y: 0, z: 0 },
        1500
      );
      
      const batches = batchTransactions(transactions);
      
      // Update batch container colors
      for (let i = 0; i < batches.length; i++) {
        if (batches[i].length > 0 && batchContainersRef.current[i]) {
          batchContainersRef.current[i].material.color.set(0x3b82f6);
          batchContainersRef.current[i].material.opacity = 0.8;
        }
      }
      
      // FIRST PHASE: Move all transactions to their respective batches
      // Process batches in sequence for better visualization
      for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
        const batch = batches[batchIndex];
        const batchContainer = batchContainersRef.current[batchIndex];
        
        if (batch.length > 0 && batchContainer) {
          // Highlight batch and focus camera on it
          batchContainer.material.color.set(0x10b981);
          
          // Calculate global position of batch container
          const batchPosition = new THREE.Vector3();
          batchContainer.getWorldPosition(batchPosition);
          
          // Add batching area offset (since containers are children of batching area)
          batchPosition.x += 5; // Add the x-offset of batching area
          
          await animateCamera(
            camera,
            { x: batchPosition.x, y: 10, z: batchPosition.z + 10 },
            { x: batchPosition.x, y: 0, z: batchPosition.z },
            600
          );
        
          // Move transactions to batch in sequence
          for (let txIndex = 0; txIndex < batch.length; txIndex++) {
            const tx = batch[txIndex];
            
            // Calculate position in batch container
            const rowCol = txIndex < 3 ? 
              { row: 0, col: txIndex } : 
              { row: 1, col: txIndex - 3 };
            
            // Position relative to batch container
            const batchPos = batchPosition;
            const batchTargetPosition = {
              x: batchPos.x - 1.5 + rowCol.col * 1.2,
              y: batchPos.y + 0.5,
              z: batchPos.z - 1.5 + rowCol.row * 1.5
            };
            
            // Highlight current transaction
            const originalColor = tx.material.color.clone();
            const originalEmissive = tx.material.emissive.clone();
            const originalEmissiveIntensity = tx.material.emissiveIntensity;
            
            tx.material.color.set(0x22c55e);
            tx.material.emissive.set(0x15803d);
            tx.material.emissiveIntensity = 0.5;
            
            // Create path to batch container
            const pathCurve = new THREE.CatmullRomCurve3([
              new THREE.Vector3(tx.position.x, tx.position.y, tx.position.z),
              new THREE.Vector3((tx.position.x + batchTargetPosition.x) * 0.5, 
                             Math.max(tx.position.y, batchTargetPosition.y) + 4, // Higher arc for longer travel distance
                             (tx.position.z + batchTargetPosition.z) * 0.5),
              new THREE.Vector3(batchTargetPosition.x, batchTargetPosition.y, batchTargetPosition.z)
            ]);
            
            // Create visual path
            const pathGeo = new THREE.TubeGeometry(
              pathCurve,
              64, // path segments
              0.05, // tube radius
              8, // tubular segments
              false // closed
            );
            
            const pathMat = new THREE.MeshBasicMaterial({
              color: 0x22c55e,
              transparent: true,
              opacity: 0.4,
            });
            
            const path = new THREE.Mesh(pathGeo, pathMat);
            batchSceneRef.current.add(path);
            
            // Follow transaction with camera
            await animateAlongPath(
              tx,
              pathCurve,
              800,
              camera,
              batchTargetPosition
            );
            
            // Remove path
            batchSceneRef.current.remove(path);
            
            // Reset transaction color
            tx.material.color.copy(originalColor);
            tx.material.emissive.copy(originalEmissive);
            tx.material.emissiveIntensity = originalEmissiveIntensity;
            
            // Small delay between transactions
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
      }
      
      // Short pause after all transactions are batched
      await new Promise(resolve => setTimeout(resolve, 800));
      
      // Step 4: Submit batches to blockchain
      setStep(4);
      setExplanation('Step 4: Batched transactions are added to the new block');
      
      // Move camera to see both batching area and blockchain
      await animateCamera(
        camera,
        { x: 10, y: 20, z: 20 }, // Adjusted to see both batching area and blockchain
        { x: 10, y: 0, z: 0 },
        1500
      );
      
      // SECOND PHASE: Move batches to blockchain
      for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
        const batch = batches[batchIndex];
        const batchContainer = batchContainersRef.current[batchIndex];
        
        if (batch.length > 0 && batchContainer) {
          // Highlight the active batch with pulsing effect
          batchContainer.material.color.set(0x22c55e); // Bright green
          batchContainer.material.emissive.set(0x15803d);
          batchContainer.material.emissiveIntensity = 0.5;
          
          // Calculate global position of batch container
          const batchPosition = new THREE.Vector3();
          batchContainer.getWorldPosition(batchPosition);
          
          // Add batching area offset (since containers are children of batching area)
          batchPosition.x += 5; // Add the x-offset of batching area
          
          // Focus camera on active batch
          await animateCamera(
            camera,
            { x: batchPosition.x, y: 10, z: batchPosition.z + 8 },
            { x: batchPosition.x, y: 1, z: batchPosition.z },
            800
          );
          
          // Add visual indicator for active batch
          const indicatorGeo = new THREE.TorusGeometry(2.5, 0.1, 16, 32);
          const indicatorMat = new THREE.MeshBasicMaterial({
            color: 0x22c55e,
            transparent: true,
            opacity: 0.7
          });
          const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
          indicator.position.set(batchPosition.x, batchPosition.y + 1, batchPosition.z);
          indicator.rotation.x = Math.PI / 2;
          batchSceneRef.current.add(indicator);
          
          // Pulse animation for indicator
          const startTime = Date.now();
          const pulseAnimation = () => {
            const elapsed = Date.now() - startTime;
            const scale = 1 + 0.2 * Math.sin(elapsed * 0.01);
            indicator.scale.set(scale, scale, scale);
            
            if (elapsed < 1000) {
              requestAnimationFrame(pulseAnimation);
            }
          };
          pulseAnimation();
          
          // Group transactions visually before sending to blockchain
          const groupCenter = new THREE.Vector3(
            batchPosition.x,
            batchPosition.y + 1.5,
            batchPosition.z
          );
          
          // First gather transactions in formation above batch
          const gatherPromises = [];
          
          for (let txIndex = 0; txIndex < batch.length; txIndex++) {
            const tx = batch[txIndex];
            
            // Scale down transaction for block
            tx.scale.set(0.5, 0.5, 0.5);
            
            // Calculate position in formation
            const angle = (txIndex / batch.length) * Math.PI * 2;
            const radius = 1.5;
            const formationPos = {
              x: groupCenter.x + Math.cos(angle) * radius,
              y: groupCenter.y + 0.5,
              z: groupCenter.z + Math.sin(angle) * radius
            };
            
            // Create a promise for gathering animation
            const gatherPromise = animatePosition(tx, formationPos, 400);
            gatherPromises.push(gatherPromise);
          }
          
          // Wait for all transactions to gather
          await Promise.all(gatherPromises);
          
          // Move camera to follow batch to blockchain
          await animateCamera(
            camera,
            { x: (batchPosition.x + batchBlockRef.current.position.x) / 2, y: 15, z: 15 },
            { x: (batchPosition.x + batchBlockRef.current.position.x) / 2, y: 0, z: 0 },
            800
          );
          
          // Create path between batch and blockchain
          const pathCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(batchPosition.x, batchPosition.y + 1.5, batchPosition.z),
            new THREE.Vector3((batchPosition.x + batchBlockRef.current.position.x) * 0.5, 
                              batchPosition.y + 3, 
                              (batchPosition.z + batchBlockRef.current.position.z) * 0.5),
            new THREE.Vector3(batchBlockRef.current.position.x, batchBlockRef.current.position.y + 2, batchBlockRef.current.position.z)
          ]);
          
          // Create visual representation of the path
          const pathGeo = new THREE.TubeGeometry(
            pathCurve,
            64, // path segments
            0.1, // tube radius
            8, // tubular segments
            false // closed
          );
          
          const pathMat = new THREE.MeshBasicMaterial({
            color: 0x22c55e,
            transparent: true,
            opacity: 0.6,
          });
          
          const path = new THREE.Mesh(pathGeo, pathMat);
          batchSceneRef.current.add(path);
          
          // Focus camera on blockchain target
          await animateCamera(
            camera, 
            { x: batchBlockRef.current.position.x - 5, y: 10, z: batchBlockRef.current.position.z + 5 },
            { x: batchBlockRef.current.position.x, y: 0, z: batchBlockRef.current.position.z },
            800
          );
          
          // Calculate final positions in blockchain block
          const finalPositions = [];
          for (let txIndex = 0; txIndex < batch.length; txIndex++) {
            const rowCol = txIndex < 3 ? 
              { row: 0, col: txIndex } : 
              { row: 1, col: txIndex - 3 };
            
            if (!batchBlockRef.current) continue;
            
            const blockPos = batchBlockRef.current.position;
            finalPositions.push({
              x: blockPos.x - 1 + rowCol.col * 0.8,
              y: blockPos.y + 0.5 + rowCol.row * 0.4, // Flatter layout for top-down visibility
              z: blockPos.z - 0.5 + rowCol.row * 0.5
            });
          }
          
          // Update transactions processed count
          transactionsProcessed += batch.length;
          
          // Stagger the movement of transactions
          for (let txIndex = 0; txIndex < batch.length; txIndex++) {
            const tx = batch[txIndex];
            
            // Small delay based on index for staggered effect
            await new Promise(resolve => setTimeout(resolve, txIndex * 50));
              
            // Animate along the path with camera following
            await animateAlongPath(
              tx, 
              pathCurve,
              800, 
              camera,
              finalPositions[txIndex]
            );
          }
          
          // Remove path and indicator
          batchSceneRef.current.remove(path);
          batchSceneRef.current.remove(indicator);
          
          // Reset batch container color
          batchContainer.material.color.set(0xe2e8f0);
          batchContainer.material.emissive.set(0xf1f5f9);
          batchContainer.material.emissiveIntensity = 0.2;
          
          // Short pause between batches
          await new Promise(resolve => setTimeout(resolve, 300));
        }
      }
      
      // Show block is mined - focus on blockchain
      if (batchBlockRef.current) {
        await animateCamera(
          camera,
          { x: 15, y: 10, z: 10 },
          { x: 15, y: 0, z: 0 },
          1000
        );
        
        batchBlockRef.current.material.color.set(0x10b981);
      }
      
      // Zoom out to show the full scene after completion
      await animateCamera(
        camera,
        { x: 0, y: 30, z: 20 },
        { x: 0, y: 0, z: 0 },
        1500
      );
      
      // Wait for a moment to show the completed state
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Calculate final statistics
      const endTime = performance.now();
      const totalTimeBatch = ((endTime - startTime) / 1000).toFixed(1);
      
      // Final overview and summary
      await animateCamera(
        camera,
        { x: 0, y: 30, z: 20 },
        { x: 0, y: 0, z: 0 },
        1000
      );
      
      // Show final message
      setExplanation(`Batch Processing: ${transactionsProcessed} transactions processed in ${totalTimeBatch}s`);
      
      return { transactionsProcessed, time: parseFloat(totalTimeBatch) };
    } catch (error) {
      console.error('Error in batch simulation:', error);
      return { transactionsProcessed: 0, time: 0 };
    }
  };
  
  // Start both simulations simultaneously
  const startComparison = async () => {
    if (isSimulating) return;
    
    setIsSimulating(true);
    setComparisonStats(null);
    
    try {
      const [batchResults, individualResults] = await Promise.all([
        runBatchSimulation(),
        runIndividualSimulation()
      ]);
      
      // Calculate speedup and set complete stats
      if (batchResults && individualResults) {
        const speedup = individualResults.time / batchResults.time;
        setComparisonStats({
          batch: {
            time: batchResults.time,
            transactionsProcessed: batchResults.transactionsProcessed
          },
          individual: {
            time: individualResults.time,
            transactionsProcessed: individualResults.transactionsProcessed
          },
          speedup
        });
      }
    } catch (error) {
      console.error("Comparison error:", error);
    } finally {
      setStep(0);
      setExplanation('Simulation complete. Click "Start Comparison" to run again.');
      setIsSimulating(false);
    }
  };
  
  // Display comparison stats if both simulations have been run
  const displayComparisonStats = () => {
    if (!comparisonStats || !comparisonStats.batch || !comparisonStats.individual) {
      return null;
    }
    
    const batchTime = parseFloat(comparisonStats.batch.time);
    const individualTime = parseFloat(comparisonStats.individual.time);
    const speedup = individualTime / batchTime;
    const efficiency = ((individualTime - batchTime) / individualTime * 100).toFixed(1);

    return (
      <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg mt-4">
        <h3 className="font-bold text-blue-800 mb-2">Performance Comparison</h3>
        <div className="grid grid-cols-2 gap-4">
          <div className="bg-white p-3 rounded shadow-sm">
            <div className="text-sm text-gray-600">Individual Processing</div>
            <div className="text-lg font-bold text-gray-800">{individualTime.toFixed(1)}s</div>
            <div className="text-xs text-gray-500">{comparisonStats.individual.count} transactions</div>
          </div>
          <div className="bg-white p-3 rounded shadow-sm">
            <div className="text-sm text-gray-600">Batch Processing</div>
            <div className="text-lg font-bold text-green-600">{batchTime.toFixed(1)}s</div>
            <div className="text-xs text-gray-500">{comparisonStats.batch.count} transactions</div>
          </div>
        </div>
        <div className="mt-3 text-center bg-green-100 p-2 rounded">
          <span className="font-bold text-green-700">
            Batching is {efficiency}% faster ({speedup.toFixed(1)}x)!
          </span>
        </div>
      </div>
    );
  };

  // Reset both simulations
  const resetSimulation = () => {
    if (isSimulating) return; // Don't reset while simulating
    
    setIsResetting(true);
    
    // Reset UI state
    setExplanation('Ready to simulate. Press Start to begin the comparison.');
    setStep(0);
    setComparisonStats(null);
    
    // Reset scenes
    if (batchSceneRef.current) {
      resetScene(batchSceneRef.current);
    }
    
    if (indivSceneRef.current) {
      resetScene(indivSceneRef.current);
    }
    
    // Reset camera positions
    if (batchCameraRef.current) {
      batchCameraRef.current.position.set(0, 40, 10);
      batchCameraRef.current.lookAt(0, 0, 0);
    }
    
    if (indivCameraRef.current) {
      indivCameraRef.current.position.set(0, 40, 10);
      indivCameraRef.current.lookAt(0, 0, 0);
    }
    
    // Reset all refs
    batchTransactionsRef.current = [];
    indivTransactionsRef.current = [];
    
    setIsResetting(false);
  };

  // Add a new function to reset the scene
  const resetScene = (scene: THREE.Scene) => {
    // Find and remove transaction objects, indicators, paths, etc.
    const objectsToRemove = [];
    
    scene.traverse((object) => {
      // Keep permanent scene elements like the blockchain and mempool
      if (object.userData && object.userData.isPermanent) {
        return;
      }
      
      // Remove temporary objects like transactions, paths, indicators
      if (object.userData && 
         (object.userData.isTransaction || 
          object.userData.isPath || 
          object.userData.isIndicator || 
          object.userData.isTemporary)) {
        objectsToRemove.push(object);
      }
    });
    
    // Remove the objects from the scene
    for (const object of objectsToRemove) {
      scene.remove(object);
    }
    
    return scene;
  };

  // Add transition effect for step changes
  const StepTransition = ({ step, children }) => {
    const [isVisible, setIsVisible] = useState(true);
    const prevStep = useRef(step);
    
    useEffect(() => {
      if (prevStep.current !== step) {
        // Step changed, animate transition
        setIsVisible(false);
        const timer = setTimeout(() => setIsVisible(true), 400);
        prevStep.current = step;
        return () => clearTimeout(timer);
      }
    }, [step]);
    
    return (
      <div className={`transition-opacity duration-400 ${isVisible ? 'opacity-100' : 'opacity-0'}`}>
        {children}
      </div>
    );
  };

  // Update the createLabel function to use CSS2DRenderer
  const createLabel = (text, position, scene) => {
    // Create HTML element for the label
    const labelDiv = document.createElement('div');
    labelDiv.className = 'scene-label';
    labelDiv.textContent = text;
    labelDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
    labelDiv.style.padding = '4px 8px';
    labelDiv.style.borderRadius = '4px';
    labelDiv.style.fontSize = '12px';
    labelDiv.style.fontWeight = 'bold';
    labelDiv.style.color = '#1e293b';
    labelDiv.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.1)';
    labelDiv.style.pointerEvents = 'none';
    
    // Create CSS2DObject to position the label in 3D space
    const labelObject = new CSS2DObject(labelDiv);
    labelObject.position.set(position.x, position.y, position.z);
    labelObject.userData = { isLabel: true, isPermanent: true };
    scene.add(labelObject);
    
    return labelObject;
  };

  // Update the initialization of renderers with CSS2DRenderer
  const setupScene = (mountRef, sceneRef, cameraRef, rendererRef, labelRendererRef, animateFunction) => {
    if (!mountRef.current) return;

    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);
    sceneRef.current = scene;

    // Create camera
    const camera = new THREE.PerspectiveCamera(
      50, // field of view
      mountRef.current.clientWidth / mountRef.current.clientHeight, // aspect ratio
      0.1, // near clipping plane
      1000 // far clipping plane
    );
    camera.position.set(0, 40, 10); // top-down view
    camera.lookAt(0, 0, 0);
    cameraRef.current = camera;

    // Create renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    rendererRef.current = renderer;
    
    // Create CSS2D renderer for labels
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    labelRendererRef.current = labelRenderer;
    
    // Clear previous content and append renderers
    while (mountRef.current.firstChild) {
      mountRef.current.removeChild(mountRef.current.firstChild);
    }
    mountRef.current.appendChild(renderer.domElement);
    mountRef.current.appendChild(labelRenderer.domElement);

    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 5);
    scene.add(directionalLight);

    // Start animation loop
    let frameId = null;
    const animate = () => {
      frameId = requestAnimationFrame(animate);
      if (animateFunction) animateFunction();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    };
    animate();

    // Handle resize
    const handleResize = () => {
      if (!mountRef.current) return;
      
      const width = mountRef.current.clientWidth;
      const height = mountRef.current.clientHeight;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      
      renderer.setSize(width, height);
      labelRenderer.setSize(width, height);
    };
    
    window.addEventListener('resize', handleResize);

    // Cleanup function
    return () => {
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
      
      if (mountRef.current) {
        while (mountRef.current.firstChild) {
          mountRef.current.removeChild(mountRef.current.firstChild);
        }
      }
      
      window.removeEventListener('resize', handleResize);
    };
  };

  return (
    <div className="flex flex-col h-full">
      {/* Batch Processing Visualization */}
      <div className="flex-1 relative border-b border-gray-200">
        <div ref={batchMountRef} className="w-full h-full" />
        <div className="absolute top-2 left-2 bg-white/80 backdrop-blur-sm p-2 rounded shadow text-sm">
          Batch Processing
        </div>
      </div>

      {/* Individual Processing Visualization */}
      <div className="flex-1 relative">
        <div ref={individualMountRef} className="w-full h-full" />
        <div className="absolute top-2 left-2 bg-white/80 backdrop-blur-sm p-2 rounded shadow text-sm">
          Individual Processing
        </div>
      </div>

      {/* Controls and Explanation */}
      <div className="p-4 border-t border-gray-200 bg-gray-50">
        <div className="flex justify-between items-center">
          <div className="flex space-x-4">
            <button
              onClick={startComparison}
              disabled={isSimulating || isResetting}
              className={`px-4 py-2 rounded font-medium ${
                isSimulating || isResetting
                  ? 'bg-gray-300 cursor-not-allowed'
                  : 'bg-blue-500 hover:bg-blue-600 text-white'
              }`}
              aria-label="Start comparison"
              tabIndex={0}
              onKeyDown={(e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                  startComparison();
                }
              }}
            >
              <FontAwesomeIcon icon={isSimulating ? faPause : faPlay} className="mr-2" />
              {isSimulating ? 'Simulating...' : 'Start Comparison'}
            </button>
            
            <button
              onClick={resetSimulation}
              disabled={isSimulating || isResetting}
              className={`px-4 py-2 rounded font-medium ${
                isSimulating || isResetting
                  ? 'bg-gray-300 cursor-not-allowed'
                  : 'bg-gray-500 hover:bg-gray-600 text-white'
              }`}
              aria-label="Reset simulation"
              tabIndex={0}
              onKeyDown={(e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                  resetSimulation();
                }
              }}
            >
              <FontAwesomeIcon icon={faSync} className="mr-2" />
              Reset
            </button>
          </div>
          
          {comparisonStats && (
            <div className="text-sm font-medium">
              <span className="text-green-600">
                Batch: {comparisonStats.batch.transactionsProcessed} txs in {comparisonStats.batch.time}s
              </span>
              <span className="mx-2">|</span>
              <span className="text-blue-600">
                Individual: {comparisonStats.individual.transactionsProcessed} txs in {comparisonStats.individual.time}s
              </span>
              <span className="mx-2">|</span>
              <span className="font-bold">
                {comparisonStats.speedup > 1
                  ? `${comparisonStats.speedup.toFixed(1)}x faster with batching`
                  : `${(1/comparisonStats.speedup).toFixed(1)}x faster with individual processing`}
              </span>
            </div>
          )}
        </div>
        
        <StepTransition step={step}>
          <div className="mt-3 text-sm text-gray-700">{explanation}</div>
        </StepTransition>
      </div>
    </div>
  );
};

export default EthereumTransactionBatching;